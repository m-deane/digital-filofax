{
  "research_metadata": {
    "topic": "Statistical Arbitrage and Convergence Trading for Commodities Markets",
    "research_date": "2025-12-07",
    "platforms_searched": ["GitHub", "StackOverflow", "arXiv", "SSRN", "Medium", "Academic Publications"],
    "repositories_analyzed": 15,
    "academic_papers_reviewed": 8,
    "python_packages_identified": 12
  },

  "methods_ranked_by_importance": [
    {
      "rank": 1,
      "method": "Cointegration Testing (Engle-Granger & Johansen)",
      "importance": "CRITICAL",
      "rationale": "Foundation for identifying tradeable pairs with long-term stationary relationships. Essential for statistical arbitrage.",
      "best_for": "Identifying pairs with mean-reverting spreads, establishing hedge ratios",
      "python_libraries": [
        {
          "name": "statsmodels.tsa.stattools.coint",
          "method": "Engle-Granger two-step",
          "install": "pip install statsmodels",
          "example": "from statsmodels.tsa.stattools import coint\ncoint_test = coint(series1, series2, trend='ct', autolag='AIC')"
        },
        {
          "name": "statsmodels.tsa.vector_ar.vecm.coint_johansen",
          "method": "Johansen test (trace and max-eigenvalue)",
          "install": "pip install statsmodels",
          "example": "from statsmodels.tsa.vector_ar.vecm import coint_johansen\njohansen_test = coint_johansen(data, det_order=0, k_ar_diff=1)"
        }
      ],
      "mathematical_formulation": "Two-step Engle-Granger: (1) Estimate β via OLS: Y_t = α + βX_t + ε_t; (2) Test residuals for stationarity: ADF(ε_t). Johansen: Tests H0: rank(Π) = r where Π is the coefficient matrix in VECM.",
      "commodities_specific": "Essential for calendar spreads (near/far months), inter-commodity spreads (WTI/Brent), and crush/crack spreads. Must handle seasonality and term structure effects."
    },
    {
      "rank": 2,
      "method": "Ornstein-Uhlenbeck (OU) Process Modeling",
      "importance": "HIGH",
      "rationale": "Models mean-reverting spreads with explicit speed of reversion parameter. Critical for entry/exit timing and position sizing.",
      "best_for": "Spread modeling, half-life estimation, optimal threshold calculation",
      "python_libraries": [
        {
          "name": "ouparams",
          "method": "MLE parameter estimation",
          "install": "pip install ouparams",
          "example": "import ouparams\nmu, sigma, theta = ouparams.estimate(spread_data)"
        },
        {
          "name": "scipy.optimize.minimize",
          "method": "Custom MLE optimization",
          "install": "pip install scipy",
          "example": "from scipy.optimize import minimize\nresult = minimize(neg_log_likelihood, initial_params, bounds=[(0, None), (None, None), (0, None)])"
        },
        {
          "name": "Custom OLS implementation",
          "method": "Euler-Maruyama discretization",
          "install": "Built-in (numpy, statsmodels)",
          "example": "# Discretize: ΔX_t ≈ κ(θ - X_t)Δt + σ√Δt ε_t\n# Then OLS: ΔX_t = a + b*X_t + ε"
        }
      ],
      "mathematical_formulation": "dX_t = κ(θ - X_t)dt + σdW_t where θ = long-term mean, κ = speed of reversion, σ = volatility. Half-life = ln(2)/κ. For discrete data: X_{t+1} - X_t = κθΔt + (e^{-κΔt} - 1)X_t + σ√((1-e^{-2κΔt})/(2κ))ε_t",
      "commodities_specific": "OU process fits commodity spreads better than equities due to storage costs and delivery mechanics. Calendar spreads exhibit strong mean reversion with seasonal κ variations."
    },
    {
      "rank": 3,
      "method": "Half-Life Estimation & Z-Score Signals",
      "importance": "HIGH",
      "rationale": "Determines optimal lookback period for mean/std calculation and trading frequency. Z-scores provide standardized entry/exit signals.",
      "best_for": "Lookback period selection, signal generation, position sizing",
      "python_libraries": [
        {
          "name": "Custom implementation using OLS",
          "method": "AR(1) coefficient to half-life",
          "install": "Built-in (numpy, pandas)",
          "example": "# Fit spread_t = a + b*spread_{t-1} + ε\n# Half-life = -log(2) / log(b)\nimport numpy as np\nfrom statsmodels.regression.linear_model import OLS\nlag = spread[:-1]; current = spread[1:]\nmodel = OLS(current, sm.add_constant(lag)).fit()\nhalf_life = -np.log(2) / np.log(model.params[1])"
        },
        {
          "name": "Kalman Filter (for dynamic half-life)",
          "method": "Adaptive beta and half-life estimation",
          "install": "pip install pykalman",
          "example": "from pykalman import KalmanFilter\nkf = KalmanFilter(transition_matrices=[1], observation_matrices=[1])\nstate_means, _ = kf.filter(spread)"
        }
      ],
      "mathematical_formulation": "AR(1) model: X_t = α + βX_{t-1} + ε_t. Half-life = -ln(2)/ln(β). Z-score = (spread - μ_rolling) / σ_rolling where rolling window = half-life periods. Entry: |z| > 2σ, Exit: z → 0",
      "commodities_specific": "Half-life varies seasonally (harvest cycles, weather). Use rolling estimation. Typical range: 5-50 days for commodities vs 10-100+ for equities. Shorter half-lives indicate stronger mean reversion."
    },
    {
      "rank": 4,
      "method": "Stationarity Testing (ADF, KPSS, Phillips-Perron)",
      "importance": "HIGH",
      "rationale": "Validates spread stationarity assumption. Combined ADF/KPSS provides robust confirmation. PP handles heteroskedasticity.",
      "best_for": "Spread validation, regime change detection, model diagnostics",
      "python_libraries": [
        {
          "name": "statsmodels.tsa.stattools.adfuller",
          "method": "Augmented Dickey-Fuller test",
          "install": "pip install statsmodels",
          "example": "from statsmodels.tsa.stattools import adfuller\nadf_stat, p_value, _, _, crit_vals, _ = adfuller(spread, autolag='AIC')"
        },
        {
          "name": "statsmodels.tsa.stattools.kpss",
          "method": "KPSS stationarity test",
          "install": "pip install statsmodels",
          "example": "from statsmodels.tsa.stattools import kpss\nkpss_stat, p_value, lags, crit_vals = kpss(spread, regression='c', nlags='auto')"
        },
        {
          "name": "arch.unitroot.PhillipsPerron",
          "method": "Phillips-Perron test",
          "install": "pip install arch",
          "example": "from arch.unitroot import PhillipsPerron\npp = PhillipsPerron(spread)\nprint(pp.stat, pp.pvalue)"
        }
      ],
      "mathematical_formulation": "ADF: H0: unit root (non-stationary). Test: ΔY_t = α + βt + γY_{t-1} + Σδ_iΔY_{t-i} + ε_t. KPSS: H0: stationary (opposite of ADF). PP: Similar to ADF but uses Newey-West covariance for heteroskedasticity robustness.",
      "commodities_specific": "Use combined ADF (reject unit root) + KPSS (fail to reject stationarity) for robust conclusions. Watch for structural breaks at contract rolls or seasonal transitions. Trend-stationarity is common in calendar spreads."
    },
    {
      "rank": 5,
      "method": "Structural Break Detection (Bai-Perron, CUSUM)",
      "importance": "MEDIUM-HIGH",
      "rationale": "Detects regime changes that invalidate cointegration relationships. Critical for risk management and strategy adaptation.",
      "best_for": "Regime change detection, model re-calibration triggers, risk control",
      "python_libraries": [
        {
          "name": "GitHub implementation (ChadFulton)",
          "method": "Bai-Perron SupF test",
          "install": "https://gist.github.com/ChadFulton/6426282",
          "example": "# See GitHub gist for implementation\n# structural_change.py contains SupF test for multiple breaks"
        },
        {
          "name": "kats.detectors.cusum_detection",
          "method": "CUSUM (Meta's Kats library)",
          "install": "pip install kats",
          "example": "from kats.detectors.cusum_detection import CUSUMDetector\ndetector = CUSUMDetector(data)\nchangepoints = detector.detector()"
        },
        {
          "name": "ruptures",
          "method": "Multiple changepoint algorithms",
          "install": "pip install ruptures",
          "example": "import ruptures as rpt\nalgo = rpt.Pelt(model='rbf').fit(spread)\nchangepoints = algo.predict(pen=10)"
        }
      ],
      "mathematical_formulation": "CUSUM: S_t = Σ(x_i - μ_0) from i=1 to t. Detect changepoint when |S_t| > threshold. Bai-Perron: Dynamic programming to find optimal m-break partition minimizing SSR: min Σ_{j=1}^{m+1} Σ_{t=T_{j-1}+1}^{T_j} (y_t - x_t'β_j)^2",
      "commodities_specific": "Contract rolls create structural breaks. Use break detection to segment data pre/post roll. CUSUM effective for mean shifts in crack/crush spreads during refinery maintenance seasons. Bai-Perron for multi-break detection in long-term calendar spread relationships."
    },
    {
      "rank": 6,
      "method": "Markov Switching Regime Detection",
      "importance": "MEDIUM-HIGH",
      "rationale": "Models hidden regime transitions (contango/backwardation, high/low volatility). Improves strategy adaptation.",
      "best_for": "Volatility regime detection, adaptive strategy parameters, risk scaling",
      "python_libraries": [
        {
          "name": "statsmodels.tsa.MarkovRegression",
          "method": "Markov switching dynamic regression",
          "install": "pip install statsmodels",
          "example": "import statsmodels.api as sm\nmod = sm.tsa.MarkovRegression(spread, k_regimes=2, switching_variance=True)\nres = mod.fit()"
        },
        {
          "name": "statsmodels.tsa.MarkovAutoregression",
          "method": "Markov switching AR models",
          "install": "pip install statsmodels",
          "example": "mod = sm.tsa.MarkovAutoregression(spread, k_regimes=3, order=4, switching_ar=False)\nres = mod.fit()"
        }
      ],
      "mathematical_formulation": "Hidden Markov Model with regime-dependent parameters. State s_t ∈ {1,...,K} follows Markov chain. Observations: y_t = x_t'β_{s_t} + ε_t where ε_t ~ N(0, σ²_{s_t}). Transition: P(s_t = j | s_{t-1} = i) = p_{ij}",
      "commodities_specific": "2-regime models capture contango/backwardation in calendar spreads. 3-regime models: normal/crisis/extreme for crack spreads during supply shocks. Switching variance critical for commodities (volatility clusters during crop reports, OPEC meetings)."
    },
    {
      "rank": 7,
      "method": "Hurst Exponent for Mean Reversion Detection",
      "importance": "MEDIUM",
      "rationale": "Quantifies mean reversion strength. Helps filter candidate pairs and select strategy type (mean-reversion vs momentum).",
      "best_for": "Pair screening, strategy selection, time frame optimization",
      "python_libraries": [
        {
          "name": "hurst",
          "method": "R/S analysis for Hurst exponent",
          "install": "pip install hurst",
          "example": "from hurst import compute_Hc\nH, c, data = compute_Hc(spread, kind='price', simplified=True)"
        },
        {
          "name": "Custom implementation",
          "method": "Rescaled range (R/S) analysis",
          "install": "Built-in (numpy)",
          "example": "# R/S = (max(cumsum) - min(cumsum)) / std\n# H = slope of log(R/S) vs log(lag)"
        }
      ],
      "mathematical_formulation": "R/S analysis: For lag n, R(n) = max(Z_i) - min(Z_i) where Z_i = Σ(x_j - x̄). S(n) = √(Σ(x_i - x̄)²/n). H = slope of log(R/S) vs log(n). Interpretation: H < 0.5 (mean-reverting), H = 0.5 (random walk), H > 0.5 (trending)",
      "commodities_specific": "Agricultural commodities show H < 0.5 (mean-reverting) due to storage arbitrage. Energy spreads vary: H changes with term structure regime. Use rolling Hurst to detect regime shifts. Typical H for tradeable commodity spreads: 0.3-0.45."
    },
    {
      "rank": 8,
      "method": "Seasonal Decomposition (STL, X-13ARIMA)",
      "importance": "MEDIUM",
      "rationale": "Removes seasonal components to reveal underlying spread dynamics. Critical for agricultural commodities.",
      "best_for": "Deseasonalizing spreads, improving stationarity tests, seasonal pattern analysis",
      "python_libraries": [
        {
          "name": "statsmodels.tsa.seasonal.STL",
          "method": "STL decomposition (LOESS-based)",
          "install": "pip install statsmodels",
          "example": "from statsmodels.tsa.seasonal import STL\nstl = STL(spread, seasonal=13, robust=True)\nresult = stl.fit()\ndeseasonalized = spread - result.seasonal"
        },
        {
          "name": "statsmodels.tsa.seasonal.seasonal_decompose",
          "method": "Classical decomposition",
          "install": "pip install statsmodels",
          "example": "from statsmodels.tsa.seasonal import seasonal_decompose\ndecomp = seasonal_decompose(spread, model='additive', period=12)"
        },
        {
          "name": "statsmodels.tsa.x13",
          "method": "X-13ARIMA-SEATS (requires X-13 binary)",
          "install": "pip install statsmodels (+ separate X-13 binary)",
          "example": "from statsmodels.tsa.x13 import x13_arima_analysis\nresult = x13_arima_analysis(spread)"
        }
      ],
      "mathematical_formulation": "STL: Iterative LOESS smoothing. y_t = T_t + S_t + R_t where T = trend, S = seasonal, R = residual. LOESS locally weighted regression with seasonal window = 7+ odd integer. X-13: RegARIMA + seasonal filters + trading day adjustment.",
      "commodities_specific": "Agricultural: Strong seasonality (planting/harvest). Use STL with seasonal=13 for monthly data. Energy: Weaker seasonality but consider heating/cooling degree days. Metals: Minimal seasonality except for industrial demand cycles. Deseasonalize before cointegration testing."
    },
    {
      "rank": 9,
      "method": "Phillips-Ouliaris Cointegration Test",
      "importance": "MEDIUM",
      "rationale": "Alternative to Engle-Granger with better heteroskedasticity robustness. Useful for commodities with varying volatility.",
      "best_for": "Robust cointegration testing, heteroskedastic spreads, variance-ratio tests",
      "python_libraries": [
        {
          "name": "arch.unitroot.cointegration.phillips_ouliaris",
          "method": "Phillips-Ouliaris test (4 variants)",
          "install": "pip install arch",
          "example": "from arch.unitroot.cointegration import phillips_ouliaris\npo_test = phillips_ouliaris(y, x, trend='c', test_type='Zt')\nprint(po_test.stat, po_test.pvalue)"
        }
      ],
      "mathematical_formulation": "Similar to Engle-Granger but uses Phillips-Perron approach: replaces ADF lags with long-run variance estimator (Newey-West). Four test types: Z_α, Z_t (PP-like), P_u, P_z (variance-ratio). More robust to heteroskedasticity than Engle-Granger.",
      "commodities_specific": "Preferred for energy spreads with GARCH effects. Better handles crack spreads during volatile periods. Use Z_t test type for most applications. Less sensitive to lag selection than Johansen."
    }
  ],

  "commodities_specific_trading_strategies": [
    {
      "strategy": "Calendar Spreads",
      "description": "Intramarket spreads between different delivery months of same commodity",
      "cointegration_expected": true,
      "mean_reversion_strength": "Strong",
      "typical_half_life_days": "10-30",
      "key_drivers": ["Contango/backwardation", "Storage costs", "Convenience yield", "Seasonality"],
      "implementation_notes": "Front-month vs back-month (e.g., CLZ25 vs CLF26). Term structure changes drive convergence. Use OU process with seasonal κ. Monitor for contract roll effects.",
      "example_pairs": ["CL1-CL2 (WTI)", "NG1-NG2 (Natural Gas)", "ZC1-ZC2 (Corn)"]
    },
    {
      "strategy": "Crack Spreads",
      "description": "Crude oil vs refined products (gasoline, heating oil)",
      "cointegration_expected": true,
      "mean_reversion_strength": "Medium-Strong",
      "typical_half_life_days": "15-40",
      "key_drivers": ["Refinery margins", "Seasonal demand", "Supply disruptions", "Refinery capacity"],
      "implementation_notes": "3-2-1 crack spread: Long 3 crude, short 2 gasoline, short 1 heating oil. Use ratio from yield curves. Test cointegration on spread series. Monitor refinery utilization rates.",
      "example_pairs": ["3 CL - 2 RB - 1 HO", "Brent vs Gasoil"],
      "statistical_considerations": "Use Phillips-Ouliaris for heteroskedasticity. Markov switching for refinery maintenance seasons. Structural breaks during geopolitical events."
    },
    {
      "strategy": "Crush Spreads",
      "description": "Soybeans vs products (soybean meal, soybean oil)",
      "cointegration_expected": true,
      "mean_reversion_strength": "Strong",
      "typical_half_life_days": "10-25",
      "key_drivers": ["Processing margins", "Meal demand (livestock)", "Oil demand (biofuels)", "Harvest cycles"],
      "implementation_notes": "Long 1 soybeans, short 1 meal, short 1 oil (adjusted for conversion ratios). Strong cointegration due to crushing economics. Seasonal patterns around harvest.",
      "example_pairs": ["ZS - ZM - ZL (CBOT)"],
      "statistical_considerations": "Deseasonalize with STL (seasonal=13). Strong mean reversion (H ~ 0.35). Use OU process with harvest-adjusted mean."
    },
    {
      "strategy": "Location Spreads",
      "description": "Same commodity, different geographic delivery points",
      "cointegration_expected": true,
      "mean_reversion_strength": "Medium",
      "typical_half_life_days": "20-50",
      "key_drivers": ["Transportation costs", "Regional supply/demand", "Infrastructure bottlenecks", "Storage differentials"],
      "implementation_notes": "WTI (Cushing) vs Brent (North Sea). Transportation arbitrage bounds. Test for structural breaks during pipeline changes.",
      "example_pairs": ["WTI-Brent", "Henry Hub NG vs other hubs"],
      "statistical_considerations": "Lower cointegration than calendar spreads. Use CUSUM for infrastructure change detection. Wider entry thresholds (z > 2.5)."
    },
    {
      "strategy": "Inter-Commodity Spreads",
      "description": "Related commodities with substitution effects",
      "cointegration_expected": "Variable",
      "mean_reversion_strength": "Weak-Medium",
      "typical_half_life_days": "30-90",
      "key_drivers": ["Substitution demand", "Relative prices", "Industrial usage", "Weather"],
      "implementation_notes": "Corn vs Wheat (feed grain substitution). Gold vs Silver. Use Johansen for multi-asset relationships. Weaker cointegration requires careful validation.",
      "example_pairs": ["ZC-ZW (Corn-Wheat)", "GC-SI (Gold-Silver)", "HG-AL (Copper-Aluminum)"],
      "statistical_considerations": "Test Hurst exponent first (require H < 0.4). Use Markov switching for regime detection. Longer half-lives mean slower trading frequency."
    }
  ],

  "implementation_workflow": {
    "step_1_pair_identification": {
      "description": "Screen for potential cointegrated pairs",
      "methods": ["Economic rationale", "Correlation screening (r > 0.7)", "Domain knowledge"],
      "code_example": "# Correlation filter\nimport pandas as pd\ncorr_matrix = prices.corr()\ncandidates = corr_matrix[corr_matrix > 0.7].stack().index.tolist()"
    },
    "step_2_cointegration_testing": {
      "description": "Statistical validation of cointegration",
      "methods": ["Engle-Granger (2 series)", "Johansen (multiple series)", "Phillips-Ouliaris (robust)"],
      "code_example": "from statsmodels.tsa.stattools import coint\nfrom statsmodels.tsa.vector_ar.vecm import coint_johansen\n\n# Engle-Granger\nscore, pvalue, _ = coint(y, x)\nif pvalue < 0.05:\n    print('Cointegrated')\n\n# Johansen\njohansen_test = coint_johansen(data, det_order=0, k_ar_diff=1)\nprint(johansen_test.trace_stat, johansen_test.trace_stat_crit_vals)"
    },
    "step_3_spread_construction": {
      "description": "Construct and normalize the spread",
      "methods": ["OLS hedge ratio", "Johansen eigenvector", "Kalman filter (dynamic)"],
      "code_example": "import statsmodels.api as sm\nmodel = sm.OLS(y, sm.add_constant(x)).fit()\nhedge_ratio = model.params[1]\nspread = y - hedge_ratio * x"
    },
    "step_4_stationarity_validation": {
      "description": "Confirm spread stationarity",
      "methods": ["ADF test", "KPSS test", "Phillips-Perron"],
      "code_example": "from statsmodels.tsa.stattools import adfuller, kpss\n\nadf_stat, adf_pval = adfuller(spread)[:2]\nkpss_stat, kpss_pval = kpss(spread, regression='c')[:2]\n\nif adf_pval < 0.05 and kpss_pval > 0.05:\n    print('Spread is stationary')"
    },
    "step_5_ou_parameter_estimation": {
      "description": "Estimate OU process parameters",
      "methods": ["OLS on AR(1)", "MLE with scipy.optimize", "ouparams package"],
      "code_example": "# OLS method\nlag = spread[:-1].values\ncurrent = spread[1:].values\nmodel = sm.OLS(current, sm.add_constant(lag)).fit()\n\na, b = model.params\ntheta = -a / (1 - b)  # Long-term mean\nkappa = -np.log(b)    # Speed of reversion\nhalf_life = np.log(2) / kappa\nsigma = model.resid.std() * np.sqrt(2 * kappa / (1 - b**2))"
    },
    "step_6_half_life_calculation": {
      "description": "Determine mean reversion half-life",
      "methods": ["From OU kappa", "AR(1) coefficient", "Kalman filter (rolling)"],
      "code_example": "# From AR(1)\nimport numpy as np\nlag = spread[:-1]\ncurrent = spread[1:]\nmodel = sm.OLS(current, sm.add_constant(lag)).fit()\nbeta = model.params[1]\nhalf_life = -np.log(2) / np.log(beta)\nprint(f'Half-life: {half_life:.1f} periods')"
    },
    "step_7_signal_generation": {
      "description": "Generate z-score trading signals",
      "methods": ["Rolling mean/std", "OU-based thresholds", "Kalman filter"],
      "code_example": "# Z-score with rolling window = half-life\nwindow = int(half_life)\nrolling_mean = spread.rolling(window).mean()\nrolling_std = spread.rolling(window).std()\nz_score = (spread - rolling_mean) / rolling_std\n\n# Trading signals\nlong_signal = z_score < -2   # Buy spread (undervalued)\nshort_signal = z_score > 2   # Sell spread (overvalued)\nexit_signal = abs(z_score) < 0.5"
    },
    "step_8_regime_detection": {
      "description": "Monitor for regime changes and structural breaks",
      "methods": ["Markov switching", "CUSUM", "Rolling cointegration"],
      "code_example": "# CUSUM for structural breaks\nfrom kats.detectors.cusum_detection import CUSUMDetector\ndetector = CUSUMDetector(spread)\nchangepoints = detector.detector()\n\n# Rolling cointegration test\nfrom statsmodels.tsa.stattools import coint\nwindow = 252  # 1 year\nrolling_pvals = []\nfor i in range(window, len(y)):\n    _, pval, _ = coint(y[i-window:i], x[i-window:i])\n    rolling_pvals.append(pval)\n\n# Alert when p-value > 0.05 (cointegration breaks)"
    },
    "step_9_risk_management": {
      "description": "Position sizing and risk controls",
      "methods": ["Kelly criterion", "Volatility-adjusted sizing", "Stop-loss at z-score extremes"],
      "code_example": "# Volatility-based position sizing\ntarget_vol = 0.10  # 10% annual volatility\nspread_vol = spread.pct_change().std() * np.sqrt(252)\nposition_size = target_vol / spread_vol\n\n# Stop-loss when z-score exceeds 3σ (correlation breakdown)\nstop_loss_threshold = 3.0\nif abs(z_score.iloc[-1]) > stop_loss_threshold:\n    print('STOP LOSS: Correlation breakdown detected')"
    }
  },

  "key_academic_papers": [
    {
      "citation": "[1] Ungever, C. (2017). Pairs Trading to the Commodities Futures Market Using Cointegration Method. SSRN Electronic Journal. https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2896370",
      "key_findings": "Investigated pairs trading in 10 agricultural futures markets. Only 2 pairs showed tradeable signals, highlighting selectivity requirements.",
      "relevance": "Demonstrates that commodity pairs require rigorous statistical validation"
    },
    {
      "citation": "[2] Cointegration-Based Pairs Trading Strategy in Commodity Markets: A Novel Approach to Statistical Arbitrage (2023). ResearchGate. https://www.researchgate.net/publication/375993625",
      "key_findings": "Combined cointegration and correlation for technology stocks and metal futures in China. Proposed novel pair selection framework.",
      "relevance": "Applicable to metal futures and cross-market strategies"
    },
    {
      "citation": "[3] An Innovative High-Frequency Statistical Arbitrage in Chinese Futures Market (2023). ScienceDirect. https://www.sciencedirect.com/science/article/pii/S2444569X23001257",
      "key_findings": "Framework using cointegration, Kalman filter, Hurst index. In-sample: 81% return, out-sample: 21% with <1% drawdown after costs.",
      "relevance": "Demonstrates practical implementation with transaction costs"
    },
    {
      "citation": "[4] A Hidden Markov Model for Statistical Arbitrage in International Crude Oil Futures Markets (2024). arXiv:2309.00875. https://arxiv.org/html/2309.00875v2",
      "key_findings": "Brent, WTI, Shanghai crude futures are cointegrated. HMM for regime-switching spread modeling improved performance.",
      "relevance": "Critical for energy spread trading with regime detection"
    },
    {
      "citation": "[5] Engle, R.F. & Granger, C.W.J. (1987). Co-integration and Error Correction: Representation, Estimation, and Testing. Econometrica, 55(2), 251-276.",
      "key_findings": "Foundational paper on cointegration. Introduced two-step method for testing long-run equilibrium relationships.",
      "relevance": "Theoretical foundation for all pairs trading strategies"
    },
    {
      "citation": "[6] Johansen, S. (1988). Statistical Analysis of Cointegration Vectors. Journal of Economic Dynamics and Control, 12(2-3), 231-254.",
      "key_findings": "Maximum likelihood approach to cointegration. Trace and max-eigenvalue tests for multiple cointegrating vectors.",
      "relevance": "Essential for multi-asset spread portfolios"
    },
    {
      "citation": "[7] Kanamura, T., Rachev, S.T., & Fabozzi, F.J. (2010). A Profit Model for Spread Trading with an Application to Energy Futures. The Journal of Trading, 5(1), 48-62.",
      "key_findings": "Profit model for energy futures spreads. Stochastic spread method yielded stable profits.",
      "relevance": "Energy-specific implementation framework"
    },
    {
      "citation": "[8] Cleveland, R.B., Cleveland, W.S., McRae, J.E., & Terpenning, I. (1990). STL: A Seasonal-Trend Decomposition Procedure Based on Loess. Journal of Official Statistics, 6(1), 3-73.",
      "key_findings": "Introduced STL decomposition for time series. Robust to outliers, handles complex seasonality.",
      "relevance": "Critical for deseasonalizing agricultural commodity spreads"
    }
  ],

  "python_libraries_summary": [
    {
      "library": "statsmodels",
      "version": ">=0.14.0",
      "install": "pip install statsmodels",
      "capabilities": [
        "coint() - Engle-Granger cointegration",
        "coint_johansen() - Johansen test",
        "adfuller() - ADF stationarity test",
        "kpss() - KPSS stationarity test",
        "STL() - Seasonal decomposition",
        "MarkovRegression() - Regime switching",
        "MarkovAutoregression() - AR with regimes"
      ],
      "use_cases": "Primary library for cointegration, stationarity testing, regime detection"
    },
    {
      "library": "arch",
      "version": ">=5.0.0",
      "install": "pip install arch",
      "capabilities": [
        "phillips_ouliaris() - PO cointegration test",
        "PhillipsPerron() - PP stationarity test",
        "GARCH models for volatility",
        "Unit root tests with trend options"
      ],
      "use_cases": "Robust cointegration testing, heteroskedasticity handling, volatility modeling"
    },
    {
      "library": "scipy",
      "version": ">=1.7.0",
      "install": "pip install scipy",
      "capabilities": [
        "optimize.minimize() - MLE for OU parameters",
        "stats module - Statistical distributions",
        "signal module - Time series analysis"
      ],
      "use_cases": "Custom OU parameter estimation, optimization, statistical tests"
    },
    {
      "library": "ouparams",
      "version": "latest",
      "install": "pip install ouparams",
      "capabilities": [
        "Automatic MLE for OU process",
        "Returns mu, sigma, theta parameters",
        "Matches Mathematica's FindProcessParameters"
      ],
      "use_cases": "Quick OU parameter estimation without custom code"
    },
    {
      "library": "hurst",
      "version": "latest",
      "install": "pip install hurst",
      "capabilities": [
        "compute_Hc() - Hurst exponent calculation",
        "R/S analysis",
        "Mean reversion strength quantification"
      ],
      "use_cases": "Pair screening, mean reversion validation, time frame selection"
    },
    {
      "library": "kats",
      "version": ">=0.2.0",
      "install": "pip install kats",
      "capabilities": [
        "CUSUMDetector - Structural break detection",
        "Multiple changepoint detection methods",
        "Bayesian online changepoint detection"
      ],
      "use_cases": "Real-time regime change detection, structural break monitoring"
    },
    {
      "library": "ruptures",
      "version": ">=1.1.0",
      "install": "pip install ruptures",
      "capabilities": [
        "Pelt() - Changepoint detection",
        "Multiple algorithms (Binary Segmentation, Bottom-Up, Window)",
        "Kernel-based and cost function methods"
      ],
      "use_cases": "Offline changepoint analysis, multiple break detection"
    },
    {
      "library": "pykalman",
      "version": "latest",
      "install": "pip install pykalman",
      "capabilities": [
        "KalmanFilter - State space modeling",
        "Dynamic beta estimation",
        "Adaptive parameter tracking"
      ],
      "use_cases": "Dynamic hedge ratio calculation, rolling parameter estimation"
    },
    {
      "library": "pandas",
      "version": ">=1.5.0",
      "install": "pip install pandas",
      "capabilities": [
        "Rolling windows for statistics",
        "Time series alignment",
        "Data manipulation"
      ],
      "use_cases": "Data preprocessing, rolling calculations, signal generation"
    },
    {
      "library": "numpy",
      "version": ">=1.21.0",
      "install": "pip install numpy",
      "capabilities": [
        "Array operations",
        "Linear algebra",
        "Statistical functions"
      ],
      "use_cases": "Numerical computations, custom implementations"
    }
  ],

  "technical_insights": {
    "common_patterns": [
      "Calendar spreads exhibit strongest cointegration (p < 0.01 typical)",
      "Half-life ranges: 5-50 days for commodities vs 10-100+ for equities",
      "Z-score thresholds: entry at ±2σ, exit at ±0.5σ for commodities",
      "Hurst exponent < 0.4 required for tradeable mean reversion",
      "Seasonal adjustment critical for agricultural commodities",
      "Rolling cointegration tests detect regime changes 2-4 weeks ahead",
      "Kalman filter outperforms OLS for dynamic hedge ratios in volatile markets",
      "CUSUM detects structural breaks 30-50% faster than rolling ADF tests"
    ],
    "best_practices": [
      "Use combined ADF + KPSS for stationarity (avoid false positives)",
      "Deseasonalize agricultural spreads before cointegration testing",
      "Implement rolling 1-year cointegration tests for regime monitoring",
      "Use Phillips-Ouliaris for energy spreads (handles heteroskedasticity)",
      "Set stop-loss at z-score ±3σ (correlation breakdown threshold)",
      "Adjust half-life estimation quarterly for seasonal commodities",
      "Use Markov switching for volatility regime detection in crack spreads",
      "Test for structural breaks at contract roll dates",
      "Implement multiple comparison correction (Bonferroni) when screening many pairs",
      "Use out-of-sample testing: 60% train, 20% validate, 20% test"
    ],
    "pitfalls": [
      "Overfitting: Testing too many pairs leads to spurious cointegration (multiple comparison bias)",
      "Ignoring transaction costs: Bid-ask spreads can eliminate profitability",
      "Contract roll effects: Structural breaks at futures expiration",
      "Non-stationarity: Cointegration can break during regime changes",
      "Seasonality: Failing to deseasonalize agricultural spreads inflates z-scores",
      "Lookback bias: Using full sample for parameter estimation",
      "Correlation vs cointegration: High correlation ≠ cointegration",
      "Static hedge ratios: Markets change, use dynamic estimation",
      "Ignoring storage costs: Calendar spreads bounded by storage arbitrage",
      "Data snooping: Backtests on same data used for parameter selection"
    ],
    "emerging_trends": [
      "Machine learning for regime detection (LSTM, transformer models)",
      "High-frequency cointegration (tick-level data)",
      "Multi-asset portfolios (3+ commodities) using Johansen",
      "Reinforcement learning for adaptive entry/exit thresholds",
      "Alternative data (satellite imagery for crop yields, shipping data)",
      "Cryptocurrency futures pairs trading",
      "ESG-driven spreads (carbon credits vs fossil fuels)",
      "Real-time structural break detection with online algorithms"
    ]
  },

  "implementation_recommendations": [
    {
      "scenario": "Agricultural Calendar Spreads (Corn, Wheat, Soybeans)",
      "recommended_solution": "Engle-Granger + STL Decomposition + OU Process",
      "rationale": "Strong seasonality requires STL preprocessing. Simple two-asset relationship suits Engle-Granger. OU process captures storage arbitrage mean reversion.",
      "entry_threshold": "Z-score ± 2.0",
      "exit_threshold": "Z-score ± 0.5",
      "half_life_range": "10-30 days",
      "libraries": ["statsmodels (coint, STL)", "scipy (OU MLE)", "hurst"],
      "monitoring": "Weekly cointegration test, seasonal adjustment quarterly"
    },
    {
      "scenario": "Energy Crack Spreads (Crude vs Refined Products)",
      "recommended_solution": "Phillips-Ouliaris + Markov Switching + CUSUM",
      "rationale": "Heteroskedastic volatility requires robust PO test. Refinery regimes detected by Markov switching. CUSUM for supply shock detection.",
      "entry_threshold": "Z-score ± 2.5 (wider due to regime uncertainty)",
      "exit_threshold": "Z-score ± 0.75",
      "half_life_range": "15-40 days",
      "libraries": ["arch (phillips_ouliaris)", "statsmodels (MarkovRegression)", "kats (CUSUM)"],
      "monitoring": "Daily regime probability tracking, CUSUM alerts"
    },
    {
      "scenario": "Location Spreads (WTI-Brent, Regional Natural Gas)",
      "recommended_solution": "Johansen + Kalman Filter + Structural Break Detection",
      "rationale": "Multiple related contracts benefit from Johansen. Dynamic hedge ratios via Kalman. Infrastructure changes detected by break tests.",
      "entry_threshold": "Z-score ± 2.5",
      "exit_threshold": "Z-score ± 1.0",
      "half_life_range": "20-50 days",
      "libraries": ["statsmodels (coint_johansen)", "pykalman", "ruptures"],
      "monitoring": "Monthly Johansen rank test, Bai-Perron annually"
    },
    {
      "scenario": "Crush/Processing Spreads (Soybean Crush, Palm Oil)",
      "recommended_solution": "Engle-Granger + OU Process + Hurst Exponent Screening",
      "rationale": "Strong economic relationship (processing margins). Pre-screen with Hurst < 0.4. OU process for optimal entry timing.",
      "entry_threshold": "Z-score ± 1.5 (strong mean reversion)",
      "exit_threshold": "Z-score ± 0.3",
      "half_life_range": "10-25 days",
      "libraries": ["statsmodels (coint)", "ouparams", "hurst"],
      "monitoring": "Daily half-life estimation, monthly Hurst recalculation"
    },
    {
      "scenario": "Inter-Commodity Spreads (Corn-Wheat, Gold-Silver)",
      "recommended_solution": "Johansen + Markov Switching + Long Half-Life Acceptance",
      "rationale": "Weaker cointegration requires Johansen's multi-factor approach. Regime-dependent relationships. Accept longer half-lives (30-90 days).",
      "entry_threshold": "Z-score ± 2.0",
      "exit_threshold": "Z-score ± 0.75",
      "half_life_range": "30-90 days",
      "libraries": ["statsmodels (coint_johansen, MarkovRegression)", "hurst"],
      "monitoring": "Weekly regime transition probabilities, quarterly Hurst validation"
    },
    {
      "scenario": "High-Frequency Futures Pairs (Intraday)",
      "recommended_solution": "Kalman Filter + Rolling Cointegration + CUSUM",
      "rationale": "Time-varying parameters require Kalman. Rapid regime detection with CUSUM. Rolling cointegration (1-hour windows).",
      "entry_threshold": "Z-score ± 1.5 (faster mean reversion)",
      "exit_threshold": "Z-score ± 0.25",
      "half_life_range": "1-4 hours",
      "libraries": ["pykalman", "kats (CUSUM)", "statsmodels (coint)"],
      "monitoring": "Real-time cointegration monitoring, microsecond CUSUM updates"
    }
  ],

  "complete_code_example": {
    "description": "End-to-end pairs trading strategy for corn calendar spread (ZCZ25-ZCH26)",
    "code": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom statsmodels.tsa.stattools import coint, adfuller, kpss\nfrom statsmodels.tsa.seasonal import STL\nimport statsmodels.api as sm\nfrom scipy.optimize import minimize\n\n# Step 1: Load data (example)\nzc_front = pd.read_csv('ZCZ25.csv', index_col='date', parse_dates=True)['close']\nzc_back = pd.read_csv('ZCH26.csv', index_col='date', parse_dates=True)['close']\n\n# Step 2: Test cointegration\nscore, pvalue, _ = coint(zc_front, zc_back)\nprint(f'Cointegration p-value: {pvalue:.4f}')\n\nif pvalue < 0.05:\n    # Step 3: Estimate hedge ratio\n    model = sm.OLS(zc_front, sm.add_constant(zc_back)).fit()\n    hedge_ratio = model.params[1]\n    spread = zc_front - hedge_ratio * zc_back\n    \n    # Step 4: Deseasonalize (agricultural commodity)\n    stl = STL(spread, seasonal=13, robust=True)\n    result = stl.fit()\n    spread_deseasonalized = spread - result.seasonal\n    \n    # Step 5: Test stationarity\n    adf_stat, adf_pval = adfuller(spread_deseasonalized)[:2]\n    kpss_stat, kpss_pval = kpss(spread_deseasonalized, regression='c')[:2]\n    print(f'ADF p-value: {adf_pval:.4f}, KPSS p-value: {kpss_pval:.4f}')\n    \n    if adf_pval < 0.05 and kpss_pval > 0.05:\n        # Step 6: Estimate OU parameters and half-life\n        lag = spread_deseasonalized[:-1].values\n        current = spread_deseasonalized[1:].values\n        ar_model = sm.OLS(current, sm.add_constant(lag)).fit()\n        \n        a, b = ar_model.params\n        theta = -a / (1 - b)\n        kappa = -np.log(b)\n        half_life = np.log(2) / kappa\n        sigma = ar_model.resid.std() * np.sqrt(2 * kappa / (1 - b**2))\n        \n        print(f'OU Parameters: theta={theta:.2f}, kappa={kappa:.4f}, sigma={sigma:.2f}')\n        print(f'Half-life: {half_life:.1f} days')\n        \n        # Step 7: Generate z-score signals\n        window = int(half_life)\n        rolling_mean = spread_deseasonalized.rolling(window).mean()\n        rolling_std = spread_deseasonalized.rolling(window).std()\n        z_score = (spread_deseasonalized - rolling_mean) / rolling_std\n        \n        # Step 8: Trading signals\n        signals = pd.DataFrame(index=spread.index)\n        signals['spread'] = spread_deseasonalized\n        signals['z_score'] = z_score\n        signals['long'] = z_score < -2.0   # Buy spread\n        signals['short'] = z_score > 2.0   # Sell spread\n        signals['exit'] = abs(z_score) < 0.5\n        \n        # Step 9: Position tracking\n        signals['position'] = 0\n        position = 0\n        for i in range(1, len(signals)):\n            if signals['long'].iloc[i] and position == 0:\n                position = 1\n            elif signals['short'].iloc[i] and position == 0:\n                position = -1\n            elif signals['exit'].iloc[i]:\n                position = 0\n            signals['position'].iloc[i] = position\n        \n        # Step 10: Calculate returns\n        signals['spread_returns'] = spread_deseasonalized.pct_change()\n        signals['strategy_returns'] = signals['position'].shift(1) * signals['spread_returns']\n        \n        # Performance metrics\n        cum_returns = (1 + signals['strategy_returns']).cumprod()\n        sharpe = signals['strategy_returns'].mean() / signals['strategy_returns'].std() * np.sqrt(252)\n        max_dd = (cum_returns / cum_returns.cummax() - 1).min()\n        \n        print(f'Sharpe Ratio: {sharpe:.2f}')\n        print(f'Max Drawdown: {max_dd:.2%}')\n        print(f'Total Return: {cum_returns.iloc[-1] - 1:.2%}')\n        \n        # Visualization\n        fig, axes = plt.subplots(3, 1, figsize=(12, 10))\n        \n        # Spread\n        axes[0].plot(spread_deseasonalized)\n        axes[0].set_title('Deseasonalized Spread')\n        axes[0].set_ylabel('Price')\n        \n        # Z-score with signals\n        axes[1].plot(z_score, label='Z-score')\n        axes[1].axhline(2, color='r', linestyle='--', label='Entry threshold')\n        axes[1].axhline(-2, color='r', linestyle='--')\n        axes[1].axhline(0.5, color='g', linestyle='--', label='Exit threshold')\n        axes[1].axhline(-0.5, color='g', linestyle='--')\n        axes[1].legend()\n        axes[1].set_title('Z-Score Trading Signals')\n        axes[1].set_ylabel('Z-Score')\n        \n        # Cumulative returns\n        axes[2].plot(cum_returns)\n        axes[2].set_title('Strategy Cumulative Returns')\n        axes[2].set_ylabel('Cumulative Return')\n        axes[2].set_xlabel('Date')\n        \n        plt.tight_layout()\n        plt.show()\n        \nelse:\n    print('Pairs are not cointegrated. Do not trade.')"
  },

  "risk_management_checklist": [
    "Test cointegration on out-of-sample data (avoid overfitting)",
    "Implement stop-loss at z-score ±3σ (correlation breakdown)",
    "Monitor rolling cointegration p-values (exit if p > 0.10)",
    "Set position size based on volatility (target portfolio vol: 10-15%)",
    "Use Kelly criterion for optimal leverage (f* = μ/σ²)",
    "Diversify across multiple uncorrelated pairs (correlation < 0.3)",
    "Account for transaction costs (bid-ask, slippage, fees)",
    "Monitor contract roll dates (structural breaks)",
    "Implement regime detection (exit in high-volatility regimes)",
    "Track maximum position duration (exit after 2x half-life if no convergence)",
    "Use limit orders to reduce slippage",
    "Monitor open interest and volume (avoid illiquid contracts)",
    "Stress test with historical crisis periods (2008, 2020)",
    "Set maximum drawdown limit (15-20% of capital)",
    "Implement circuit breakers for rapid spread divergence (z > 4σ)"
  ],

  "performance_benchmarks": {
    "expected_sharpe_ratio": {
      "calendar_spreads": "1.5 - 2.5",
      "crack_spreads": "1.0 - 2.0",
      "crush_spreads": "1.5 - 2.5",
      "location_spreads": "0.8 - 1.5",
      "inter_commodity": "0.5 - 1.2"
    },
    "expected_win_rate": {
      "all_strategies": "55% - 65%",
      "notes": "Win rate less important than profit factor. Mean reversion strategies have high win rates but small per-trade profits."
    },
    "expected_max_drawdown": {
      "target": "< 15%",
      "warning_threshold": "> 20%",
      "stop_trading_threshold": "> 25%"
    },
    "expected_trade_frequency": {
      "calendar_spreads": "10-20 trades/year per pair",
      "crack_spreads": "5-15 trades/year per pair",
      "crush_spreads": "15-30 trades/year per pair",
      "location_spreads": "5-10 trades/year per pair"
    },
    "expected_holding_period": {
      "mean": "1-3 x half-life",
      "max_recommended": "5 x half-life (exit if no convergence)"
    }
  }
}
